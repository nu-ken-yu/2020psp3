# 課題5 レポート
35319015　沖野玄勇


## 課題
本課題では、以下の3つのプログラムを作成する。なお、出発駅、到着駅は、適宜変更しても良い。
- 赤迫駅を出発点として、深さ優先探索ですべての駅に到達可能なことを確認するプログラム。到達した駅名を出力するなど、各駅に1回到達したことを確認すること。  
- 赤迫駅を出発点として、幅優先探索ですべての駅に到達可能なことを確認するプログラム。到達した駅名を出力するなど、各駅に1回到達したことを確認すること。  
- 赤迫駅を出発点として、蛍茶屋駅までの最短所要時間ルートをダイクストラ法で見つけ、出力するプログラム
路線図、および、駅間の所要時間は下記のようになっている。  

1.使用するデータ  
路線図、及び、駅間の所要時間は下記のようになっている。なお、プログラムにおいて、駅名はArrayStation、グラフは隣接行列AdjacencyMatrixに保存されている。  

<img src=images/routemap.png width=600>  

```
typedef struct tagStation {
    char name[20];
    char kanji[16];
} Station;

Station ArrayStation[MAX_STATIONS] = {
    {"akasako", "赤迫"},
    {"nagasakidaigakumae", "長崎大学前"},
    {"nagasakiekimae", "長崎駅前"},
    {"shinchichukagai", "新地中華街"},
    {"ishibashi", "石橋"},
    {"sofukuji", "崇福寺"},
    {"shiminkaikan", "市民会館"},
    {"hotarujaya", "蛍茶屋"},
};

int AdjacencyMatrix[MAX_STATIONS][MAX_STATIONS] = {
    {0,  5,  0,  0,  0,  0,  0,  0},
    {5,  0, 16,  0,  0,  0,  0,  0},
    {0, 16,  0,  7,  0,  0,  5,  0},
    {0,  0,  7,  0,  7,  6, 10,  0},
    {0,  0,  0,  7,  0,  0,  0,  0},
    {0,  0,  0,  6,  0,  0, 10,  0},
    {0,  0,  5, 10,  0, 10,  0,  6},
    {0,  0,  0,  0,  0,  0,  6,  0},
};
```


2. 必須問題：実装する関数  
本課題では、以下の関数を実装する。  
(1) DepthFirstSearch: 深さ優先探索ですべての駅に到達可能なことを確認する  
    [入力]
    - int size: 駅の数　　
    - int matrix[size][size]: 隣接行列
    - int start: 出発駅のインデックス  

    [出力]  
    - なし。関数の出力はないが、関数内でprintf文を使うなど、すべての駅に到達可能なことをチェックすること。  


    (2) BreadthFirstSearch: 幅優先探索ですべての駅に到達可能なことを確認する  
    [入力]
    - int size: 駅の数　　
    - int matrix[size][size]: 隣接行列
    - int start: 出発駅のインデックス  

    [出力]  
    - なし。関数の出力はないが、関数内でprintf文を使うなど、すべての駅に到達可能なことをチェックすること。

    (3) SearchGraphByDijkstra: ダイクストラ法で、出発駅から到着駅までの最短所要時間ルートを探索する。  
    [入力]  
    - int start: 出発駅のインデックス
    - int goal: 到着駅のインデックス  
    - int size: 駅数  
    - int matrix[size][size]: 隣接行列  
    - NodeInfo arrayNodeInfo[size]:  

    [出力]  
    - return値: 出発駅から到着駅までの所要時間 
    - 関数内でprintf文を使い、最短ルートを出力すること

3. 補助関数  
以下の関数はすでに実装されており、利用することができる。
- PrintStationName: indexで指定される駅名を出力する
- StackInit: スタックを初期化する
- StackPush: スタックに値をプッシュする
- StackPop: スタックから値をポップする
- StackTop: スタックの先頭の値を取得する(スタックポインタは移動しない)
- StackIsEmpty: スタックが空か判断する。空の場合はTRUE、空でなければFALSEを返す。
- InitQueue: キューを初期化する
- EnQueue: キューに値を入れる
- DeQueue: キューから値を取り出す
- QueueIsEmpty: キューが空か判断する。空の場合はTRUE、空でなければFALSEを返す。
- main: メイン関数。深さ優先探索、幅優先探索、ダイクストラ法による最短経路探索処理を呼び出す。

4. チャレンジ課題  
赤迫駅を起点として、各駅にたどり着くまでのルートを、深さ優先探索、幅優先探索のそれぞれの場合で出力するようにプログラムを修正する。  
- 深さ優先探索のルート表示(10点)
- 幅優先探索のルート表示(10点)

## ソースコードの説明
(1)深さ優先探索
その駅を訪問したかどうかを確かめるための配列visitedの要素をすべて0（訪問していない）に初期化する。
スタックを初期化し、startをプッシュする。
ループはスタックが空になるまで繰り返す。
ポップした値を変数checkPointに代入。
もし、visitedのcheckPoint番目が0ならば、それを1（訪問した）にし、駅名を出力。
その駅から行くことができる駅、つまり２次元配列matrixのcheckPoint行目の0になってない要素をプッシュする。
(2)幅優先探索
その駅を訪問したかどうかを確かめるための配列visitedの要素をすべて0（訪問していない）に初期化する。
スタックを初期化し、startをエンキューする。
ループはキューが空になるまで繰り返す。
デキューした値を変数checkPointに代入。
もし、visitedのcheckPoint番目が0ならば、それを1（訪問した）にし、駅名を出力。
その駅から行くことができる駅、つまり２次元配列matrixのcheckPoint行目の0になってない要素をエンキューする。
(3)ダイクストラ法
その駅までにかかる時間を保持する配列costのすべての要素を9999で初期化、その駅までにかかる時間が確定したかどうかを判定するための配列fixedを0（確定していない）で初期化し、costのstart番目の値を0、その駅にはどの駅から来たかを確かめるための配列fromのstart番目の値をを-1にする。
ループは無限ループにしておく。
fixedが0（時間が確定しない）の駅の中から所要時間が最も短い駅の添え字をminIndexに代入し、fixedのminIndex番目を1（時間が確定）にする。もし、minIndexがgoalならば無限ループを抜け、costのgoal番目の値を返す。
そうでなければ、minIndex番目の駅から行くことができる駅かつまだ所要時間が確定していない駅で、新しい所要時間がそれまで保持していた所要時間よりも小さい駅の所要時間を更新し、fromをminIndexに更新する。
最小所要時間を探すときに用いたminCostを9999に更新。
ループを抜けた後にfromを用いて最短ルートを出力する。


## 出力結果

```
----DepthFirstSerch----
赤迫
長崎大学前
長崎駅前
市民会館
蛍茶屋
崇福寺
新地中華街
石橋
----BreadthFirstSerch----
赤迫
長崎大学前
長崎駅前
新地中華街
市民会館
石橋
崇福寺
蛍茶屋
----SearchGraphByDijkstra----
蛍茶屋
市民会館
長崎駅前
長崎大学前
赤迫
Time Required: 32
```

## 修正履歴

