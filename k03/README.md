# 課題3 レポート
35319015　沖野玄勇


## 課題  

以下の2つのアルゴリズムで文字列を検索するプログラムを作成する。  
- 力ずく法
- BM法

1. 使用するデータ  
以下のデータを使用する。ただし、検索対象文字列、検索する文字列は変更しても良い。  
    - StrOriginal: 検索対象データ
    - StrKey: 検索する文字列

2. 必須問題：実装する関数  
本課題では、以下の関数を実装する。C言語の標準ライブラリは使用しないこと。  
    (1) ForceSearch: 力ずく法で文字列を検索する。  
    [入力]  
    - char text[]: 検索対象文字列  
    - char key[]: 検索する文字列  

    [出力]  
    - return値：検索する文字列が出現した場所(ポインタ)。ただし、検索する文字列が見つからない場合はNULL。  

    (2) BMSearch: BM法で文字列を検索する。  
    [入力]  
    - char text[]: 検索対象文字列  
    - char key[]: 検索する文字列  
 
    [出力]  
    - return値：検索する文字列が出現した場所(ポインタ)。ただし、検索する文字列が見つからない場合はNULL。  

3. 補助関数  
なし

## ソースコードの説明
(1)力ずく法
まず、検索する文字列の長さを求める。
検索対象文字列の検索開始位置から検索対象文字列の最後尾の間で、検索する文字列の長さ分の文字列が確保できなければそれ以上検索する意味はなく、検索する文字列が見つからなかったと言ことになるため、20行目のような条件分になっている。
検索対象文字列のstart + pos番目と検索する文字列のpos番目が等しければ、posをインクリメントするという作業を繰り返し、posが検索する文字列の長さと等しくなれば、検索対象文字列に検索する文字列が見つかったということになる。
検索対象文字列のstart + pos番目と検索する文字列のpos番目が等しくなければ、startをインクリメントし、posを0に更新する。

(2)BM法
検索対象文字列と検索する文字列の長さを求める。
検索対象文字列の検索開始位置を検索する文字列の長さ - 1で初期化する。- 1は'\0'の分。
次にずらし量を格納する配列tableを作るのだが、まずは配列tableの全てに検索する文字列の長さを格納する。
そして、検索する文字列に含まれる文字のずらし量を配列tableに格納する。
検索開始位置が検索対象文字列の'\0'よりも前にある間検索を行う。
検索対象文字列のstart - dis番目と検索する文字列のkey_len - dis - 1番目が等しい間disをインクリメントする。(disは0で初期化している。- 1は'\0'の分)
そして、disがkey_lenと等しくなれば検索する文字列が見つかったということになる。リターンする際のdisは見つかった際のdisよりも１大きくなっているため、68行目のようにしている。
検索対象文字列のstart - dis番目と検索する文字列のkey_len - dis - 1番目が等しくなければ、検索開始位置を配列tableを用いて更新。もし、更新した検索開始位置が更新する前の検索開始位置よりも前もしくわ変わらないならば、検索開始位置を更新する前の検索開始位置 + 1で更新。そしてdisを0で更新。



## 出力結果
・見つかった時
Force Search. Find keyword at:wind in my hair.
BM Search. Find keyword at:wind in my hair.

・見つからなかった時(key = "winder")
Force Search. Find keyword at:(null)
BM Search. Find keyword at:(null)
## 修正履歴

